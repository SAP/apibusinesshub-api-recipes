'use strict';

var crypto = require('crypto');
var querystring = require ('querystring');
var tough = require('tough-cookie');
var uaaUtils = require('./uaa-utils');

var SESSION_SECRET_LENGTH = 64;

exports.generateSessionSecret = function() {
  return crypto.randomBytes(SESSION_SECRET_LENGTH).toString('hex');
};

exports.getBackendCookiesSecret = function () {
  return process.env.BACKEND_COOKIES_SECRET || exports.generateSessionSecret();
};

const resizedIV = Buffer.allocUnsafe(16);
const iv = crypto
    .createHash('sha256')
    .update(exports.getBackendCookiesSecret())
    .digest();
iv.copy(resizedIV);
const key = crypto
    .createHash('sha256')
    .update(exports.getBackendCookiesSecret())
    .digest();

exports.setCookie = function (res, cookie) {
  var oldCookies = res.getHeader('set-cookie');
  res.setHeader('set-cookie', oldCookies ? [].concat(oldCookies, cookie) : cookie);
};

exports.getSessionCookieName = function() {
  // This cookie name 'JSESSIONID' tells Cloud Foundry to use session stickiness
  // https://docs.cloudfoundry.org/devguide/deploy-apps/prepare-to-deploy.html#sessions
  // https://github.com/cloudfoundry/gorouter/issues/26
  return getCookieName('AR-', 'JSESSIONID');
};

exports.getRedirectLocationCookieName = function() {
  return getCookieName('ARLOC-', 'locationAfterLogin');
};

exports.getFragmentCookieName = function() {
  return getCookieName('ARFRG-', 'fragmentAfterLogin');
};

exports.getBackendCookieName = function() {
  return getCookieName('ARBE-', 'ARBE');
};

function getCookieName(prefix, defaultCookieName) {
  if ('USE_JSESSION_COOKIE_SUFFIX_REQUIRED' in process.env && process.env.VCAP_APPLICATION) {
    // With port based routing the session cookies of two app router applications may
    // overwrite/reuse each other if the browser ignores the port of the applications
    var vcapApplication = JSON.parse(process.env.VCAP_APPLICATION);
    if (vcapApplication.application_id) {
      return prefix + compactGuid(vcapApplication.application_id);
    }
  }
  return defaultCookieName;
}

function compactGuid(guid) {
  return guid.split('-').map(function (segment) {
    return parseInt(segment, 16).toString(36);
  }).join('');
}

exports.signCookie = function (req, value, cb) {
  uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
    if (err) {
      return cb(err);
    }
    if (!uaaOptions || !uaaOptions.clientsecret) {
      return cb('Invalid UAA options');
    }

    var hash = crypto
        .createHash('sha1')
        .update(value + '-' + uaaOptions.clientsecret, 'ascii')
        .digest('base64');
    return cb(null, querystring.escape (hash));
  });
};

exports.verifyCookie = function (req, value, signature, cb) {
  exports.signCookie (req, value, function (err, hash) {
    if (err) {
      return cb(err);
    }
    if (hash === querystring.escape (signature)) {
      cb ();
    }
    else {
      cb ('Signature does not match');
    }
  });
};

// See: https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module/
exports.encryptCookies = function (cookies, backendName) {
  const msg = [];
  const cipher = crypto.createCipheriv('aes256', key, resizedIV);
  msg.push(cipher.update(JSON.stringify({[backendName]: cookies.map(cookie=>cookie.key + '=' + cookie.value)}), 'binary', 'hex'));
  msg.push(cipher.final('hex'));
  return exports.getBackendCookieName() + '=' + msg.join('') + '; Path=/; HttpOnly;';
};

exports.decryptCookies = function (cookies, backendName) {
  let idx = -1;
  const msg = [];
  const backendCookieName = exports.getBackendCookieName();
  const parsedCookies = cookies.split(';').map(cookie => tough.Cookie.parse(cookie));
  const encryptedCookie = parsedCookies.find((cookie, i) => (cookie.key === backendCookieName) && (idx = i) >= 0);
  if (encryptedCookie) {
    parsedCookies.splice(idx,1);
    const decipher = crypto.createDecipheriv('aes256', key, resizedIV);
    msg.push(decipher.update(encryptedCookie.value, 'hex', 'binary'));
    msg.push(decipher.final('binary'));
    parsedCookies.push((JSON.parse(msg.join(''))[backendName] || []).map(cookie => {
      const {key, value} = tough.Cookie.parse(cookie);
      return key + '=' + value;
    }).join('; '));
    return parsedCookies.join(';');
  } else {
    return cookies;
  }
};

exports.getBackendName = function (req) {
  return req && req.internalUrl && req.internalUrl.route &&
      (req.internalUrl.route.destination || req.internalUrl.route.service);
};
